import{t as u,r as P}from"./index-BcP1mcEX.js";function d(){return d=Object.assign?Object.assign.bind():function(s){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(s[n]=t[n])}return s},d.apply(this,arguments)}const K=(s,e)=>{const t={};for(const n in s)e.indexOf(n)===-1&&(t[n]=s[n]);return t},ee=u.createContext(null),G=u.createContext(null),y=s=>e=>u.createElement(G.Consumer,null,t=>u.createElement(s,d({parent:t},e))),oe=(s=[])=>{const[e,t]=P.useState(!1),n=P.useRef(s),o=(()=>{const i=P.useContext(ee);if(i===null)throw new Error("Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider");return i})(),l=o.getApi();return P.useEffect(()=>{o.load().then(()=>Promise.all(n.current.map(o.loadModule))).then(()=>t(!0))},[]),e&&l?l:null},se=()=>{},re=["onLoad","onError","modules","apiLoader"];function f(s,e=!1,t=[]){return n=>{const{width:o,height:l,modules:i=[],onLoad:p=se}=n,a=oe(t.concat(i)),r=!e||!!a,O=K(n,re);return P.useEffect(()=>a?p(a):void 0,[a]),r?u.createElement(s,d({ymaps:a},O)):u.createElement("div",{style:{width:o,height:l}})}}const ae=typeof window<"u",X={lang:"ru_RU",load:"",ns:"",mode:"release"},me=s=>{const{version:e="2.1",enterprise:t=!1,query:n={lang:"ru_RU",load:"",ns:""},preload:o=!1,children:l}=s,i=P.useRef((p=>{const{query:a=X}=p,r=Date.now().toString(32),O=a.ns||"",g="__yandex-maps-api-onload__$$"+r,E="__yandex-maps-api-onerror__$$"+r,R=ae?window:{},Z={};let k;const V=()=>O?R[O]:k,J=()=>{delete R[g],delete R[E]};return{load:()=>{if(V())return Promise.resolve(k);if(Z[O])return Z[O];const B={onload:g,onerror:E,...X,...a},I=Object.keys(B).map(T=>`${T}=${B[T]}`).join("&"),W=[`https://${p.enterprise?"enterprise.":""}api-maps.yandex.ru`,p.version,"?"+I].join("/");return Z[O]=new Promise((T,F)=>{R[g]=w=>{J(),w.ready(()=>{k=w,T(w)})},R[E]=w=>{J(),F(w)},(w=>new Promise((U,q)=>{const _=document.createElement("script");_.type="text/javascript",_.onload=U,_.onerror=q,_.src=w,_.async=!0,document.head.appendChild(_)}))(W).catch(R[E])}),Z[O]},getApi:V,loadModule:B=>new Promise((I,W)=>{k.modules.require(B).done(T=>{T.forEach(F=>{((w,U,q,_=!1)=>{const Y=typeof U=="string"?U.split("."):U.slice();let z,S=w;for(;Y.length>1;)z=Y.shift(),S[z]||(S[z]={}),S=S[z];const Q=Y[0];S[Q]=_===!0&&S[Q]||q})(k,B,F,!0)}),I(k)},W)})}})({version:e,enterprise:t,query:n}));return P.useEffect(()=>{o&&i.current.load()},[i.current]),u.createElement(ee.Provider,{value:i.current},l)},H=/^on(?=[A-Z])/;function m(s){return Object.keys(s).reduce((e,t)=>{if(H.test(t)){const n=t.replace(H,"").toLowerCase();e._events[n]=s[t]}else e[t]=s[t];return e},{_events:{}})}function x(s,e,t){typeof t=="function"&&s.events.add(e,t)}function M(s,e,t){typeof t=="function"&&s.events.remove(e,t)}function D(s,e,t){Object.keys(Object.assign({},e,t)).forEach(n=>{e[n]!==t[n]&&(M(s,n,e[n]),x(s,n,t[n]))})}const te=s=>"default"+s.charAt(0).toUpperCase()+s.slice(1);function b(s,e){return s[e]!==void 0||s[te(e)]===void 0}function c(s,e,t){return(b(s,e)?s[e]:s[te(e)])||t}function v(s,e,t=null){if(s!==e){if(s&&("current"in s?s.current=null:typeof s=="function"&&s(null)),!e)return;"current"in e?e.current=t:typeof e=="function"&&e(t)}}function ne(s){const{width:e,height:t,style:n,className:o}=s;return n!==void 0||o!==void 0?Object.assign({},n&&{style:n},o&&{className:o}):{style:{width:e,height:t}}}class ce extends u.Component{constructor(e){super(e),this.state={error:null,errorInfo:null}}componentDidCatch(e,t){const{onError:n=()=>{}}=this.props;n(e),this.setState({error:e,errorInfo:t})}render(){return this.state.error?null:this.props.children}}const h=s=>({onError:e,...t})=>u.createElement(ce,{onError:e},u.createElement(s,t));class A extends u.Component{constructor(){super(),this.instance=null,this.state={instance:null},this._parentElement=null,this._getRef=e=>{this._parentElement=e}}componentDidMount(){this.instance=A.mountObject(this._parentElement,this.props.ymaps.Map,this.props),this.setState({instance:this.instance})}componentDidUpdate(e){this.instance!==null&&A.updateObject(this.instance,e,this.props)}componentWillUnmount(){A.unmountObject(this.instance,this.props)}render(){const e=ne(this.props),t=m(this.props),n=K(t,["_events","state","defaultState","options","defaultOptions","instanceRef","ymaps","children","width","height","style","className"]);return u.createElement(G.Provider,{value:this.state.instance},u.createElement("div",d({ref:this._getRef},e,n),this.props.children))}static mountObject(e,t,n){const{instanceRef:o,_events:l}=m(n),i=new t(e,c(n,"state"),c(n,"options"));return Object.keys(l).forEach(p=>x(i,p,l[p])),v(null,o,i),i}static updateObject(e,t,n){const{_events:o,instanceRef:l}=m(n),{_events:i,instanceRef:p}=m(t);if(b(n,"state")){const a=c(t,"state",{}),r=c(n,"state",{});a.type!==r.type&&e.setType(r.type),a.behaviors!==r.behaviors&&(a.behaviors&&e.behaviors.disable(a.behaviors),r.behaviors&&e.behaviors.enable(r.behaviors)),r.zoom&&a.zoom!==r.zoom&&e.setZoom(r.zoom),r.center&&a.center!==r.center&&e.setCenter(r.center),r.bounds&&a.bounds!==r.bounds&&e.setBounds(r.bounds)}if(b(n,"options")){const a=c(t,"options"),r=c(n,"options",{});a!==r&&e.options.set(r)}c(t,"width")===c(n,"width")&&c(t,"height")===c(n,"height")||e.container.fitToViewport(),D(e,i,o),v(p,l,e)}static unmountObject(e,t){const{instanceRef:n,_events:o}=m(t);e!==null&&(Object.keys(o).forEach(l=>M(e,l,o[l])),e.destroy(),v(n))}}const ie=h(f(A,!0,["Map"]));ie.defaultProps={width:320,height:240};class L extends u.Component{constructor(){super(),this.state={instance:null},this._parentElement=null,this._getRef=e=>{this._parentElement=e}}componentDidMount(){this._mounted=!0,this.props.ymaps.panorama.isSupported()&&L.mountObject(this._parentElement,this.props.ymaps.panorama,this.props).then(e=>this._mounted&&this.setState({instance:e}))}componentDidUpdate(e){this.state.instance!==null&&L.updateObject(this.state.instance,e,this.props)}componentWillUnmount(){this._mounted=!1,L.unmountObject(this.state.instance,this.props)}render(){const e=ne(this.props);return u.createElement("div",d({ref:this._getRef},e))}static mountObject(e,t,n){const{instanceRef:o,_events:l}=m(n),i=c(n,"point"),p=c(n,"locateOptions"),a=c(n,"options");return new Promise((r,O)=>{t.locate(i,p).done(g=>{if(g.length>0){const E=new t.Player(e,g[0],a);v(null,o,E),Object.keys(l).forEach(R=>x(E,R,l[R])),r(E)}},O)})}static updateObject(e,t,n){const{_events:o,instanceRef:l}=m(n),{_events:i,instanceRef:p}=m(t);if(b(n,"options")){const a=c(t,"options"),r=c(n,"options");a!==r&&e.options.set(r)}if(b(n,"point")){const a=c(n,"point"),r=c(t,"point"),O=c(n,"locateOptions");a!==r&&e.moveTo(a,O)}D(e,i,o),v(p,l,e)}static unmountObject(e,t){const{instanceRef:n,_events:o}=m(t);e!==null&&(Object.keys(o).forEach(l=>M(e,l,o[l])),v(n))}}const le=h(f(L,!0,["panorama.isSupported","panorama.locate","panorama.createPlayer","panorama.Player"]));le.defaultProps={width:320,height:240};class j extends u.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const e=j.mountControl(this.props.ymaps.control[this.props.name],this.props);this.instance=e,this.setState({instance:e})}componentDidUpdate(e){this.instance!==null&&j.updateControl(this.instance,e,this.props)}componentWillUnmount(){j.unmountControl(this.instance,this.props)}render(){return u.createElement(G.Provider,{value:this.state.instance},this.props.children)}static mountControl(e,t){const{instanceRef:n,parent:o,lazy:l,_events:i}=m(t),p=new e({data:c(t,"data"),options:c(t,"options"),state:c(t,"state"),mapTypes:c(t,"mapTypes"),lazy:l});if(Object.keys(i).forEach(a=>x(p,a,i[a])),o&&o.controls&&typeof o.controls.add=="function")o.controls.add(p);else{if(!o||!o.add||typeof o.add!="function")throw new Error(`No parent found to mount ${t.name}`);o.add(p)}return v(null,n,p),p}static updateControl(e,t,n){const{_events:o,instanceRef:l}=m(n),{_events:i,instanceRef:p}=m(t);if(b(n,"options")){const a=c(t,"options"),r=c(n,"options");a!==r&&e.options.set(r)}if(b(n,"data")){const a=c(t,"data"),r=c(n,"data");a!==r&&e.data.set(r)}if(b(n,"state")){const a=c(t,"state"),r=c(n,"state");a!==r&&e.state.set(r)}if(b(n,"mapTypes")){const a=c(t,"mapTypes"),r=c(n,"mapTypes");a!==r&&(e.removeAllMapTypes(),r.forEach(O=>e.addMapType(O)))}D(e,i,o),v(p,l,e)}static unmountControl(e,t){const{instanceRef:n,parent:o,_events:l}=m(t);e!==null&&(Object.keys(l).forEach(i=>M(e,i,l[i])),o.controls&&typeof o.controls.remove=="function"?o.controls.remove(e):o.remove&&typeof o.remove=="function"&&o.remove(e),v(n))}}var de=h(y(f(s=>u.createElement(j,d({},s,{name:"Button"})),!0,["control.Button"]))),fe=h(y(f(s=>u.createElement(j,d({},s,{name:"FullscreenControl"})),!0,["control.FullscreenControl"]))),he=h(y(f(s=>u.createElement(j,d({},s,{name:"GeolocationControl"})),!0,["control.GeolocationControl"]))),ye=h(y(f(s=>u.createElement(j,d({},s,{name:"ListBox"})),!0,["control.ListBox"]))),be=h(y(f(s=>u.createElement(j,d({},s,{name:"ListBoxItem"})),!0,["control.ListBoxItem"]))),ve=h(y(f(s=>u.createElement(j,d({},s,{name:"RouteButton"})),!0,["control.RouteButton"]))),je=h(y(f(s=>u.createElement(j,d({},s,{name:"RouteEditor"})),!0,["control.RouteEditor"]))),Oe=h(y(f(s=>u.createElement(j,d({},s,{name:"RoutePanel"})),!0,["control.RoutePanel"]))),ge=h(y(f(s=>u.createElement(j,d({},s,{name:"RulerControl"})),!0,["control.RulerControl"]))),Ee=h(y(f(s=>u.createElement(j,d({},s,{name:"SearchControl"})),!0,["control.SearchControl"]))),Ce=h(y(f(s=>u.createElement(j,d({},s,{name:"TrafficControl"})),!0,["control.TrafficControl"]))),Re=h(y(f(s=>u.createElement(j,d({},s,{name:"TypeSelector"})),!0,["control.TypeSelector"]))),we=h(y(f(s=>u.createElement(j,d({},s,{name:"ZoomControl"})),!0,["control.ZoomControl"])));class $ extends u.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const e=$.mountObject(this.props.ymaps.Clusterer,this.props);this.instance=e,this.setState({instance:e})}componentDidUpdate(e){this.state.instance!==null&&$.updateObject(this.instance,e,this.props)}componentWillUnmount(){$.unmountObject(this.instance,this.props)}render(){return u.createElement(G.Provider,{value:this.state.instance},this.props.children)}static mountObject(e,t){const{instanceRef:n,parent:o,_events:l}=m(t),i=new e(c(t,"options"));if(Object.keys(l).forEach(p=>x(i,p,l[p])),o.geoObjects&&typeof o.geoObjects.add=="function")o.geoObjects.add(i);else{if(!o.add||typeof o.add!="function")throw new Error("No parent found to mount Clusterer");o.add(i)}return v(null,n,i),i}static updateObject(e,t,n){const{_events:o,instanceRef:l}=m(n),{_events:i,instanceRef:p}=m(t);if(b(n,"options")){const a=c(t,"options"),r=c(n,"options");a!==r&&e.options.set(r)}D(e,i,o),v(p,l,e)}static unmountObject(e,t){const{instanceRef:n,parent:o,_events:l}=m(t);e!==null&&(Object.keys(l).forEach(i=>M(e,i,l[i])),o.geoObjects&&typeof o.geoObjects.remove=="function"?o.geoObjects.remove(e):o.remove&&typeof o.remove=="function"&&o.remove(e),v(n))}}var _e=h(y(f($,!0,["Clusterer"])));class N extends u.Component{constructor(){super(),this.state={instance:null}}componentDidMount(){const e=N.mountObject(this.props.ymaps.ObjectManager,this.props);this.instance=e,this.setState({instance:e})}componentDidUpdate(e){this.instance!==null&&N.updateObject(this.instance,e,this.props)}componentWillUnmount(){N.unmountObject(this.instance,this.props)}render(){return null}static mountObject(e,t){const{instanceRef:n,parent:o,_events:l}=m(t),i=c(t,"options",{}),p=c(t,"features",{}),a=c(t,"filter",null),r=c(t,"objects",{}),O=c(t,"clusters",{}),g=new e(i);if(g.add(p||[]),g.setFilter(a),g.objects.options.set(r),g.clusters.options.set(O),Object.keys(l).forEach(E=>x(g,E,l[E])),o.geoObjects&&typeof o.geoObjects.add=="function")o.geoObjects.add(g);else{if(!o.add||typeof o.add!="function")throw new Error("No parent found to mount ObjectManager");o.add(g)}return v(null,n,g),g}static updateObject(e,t,n){const{_events:o,instanceRef:l}=m(n),{_events:i,instanceRef:p}=m(t);if(b(n,"options")){const a=c(t,"options"),r=c(n,"options");a!==r&&e.options.set(r)}if(b(n,"objects")){const a=c(t,"objects"),r=c(n,"objects");a!==r&&e.objects.options.set(r)}if(b(n,"clusters")){const a=c(t,"clusters"),r=c(n,"clusters");a!==r&&e.clusters.options.set(r)}if(b(n,"filter")){const a=c(t,"filter"),r=c(n,"filter");a!==r&&e.setFilter(r)}if(b(n,"features")){const a=c(t,"features"),r=c(n,"features");a!==r&&(e.remove(a),e.add(r))}D(e,i,o),v(p,l,e)}static unmountObject(e,t){const{instanceRef:n,parent:o,_events:l}=m(t);e!==null&&(Object.keys(l).forEach(i=>M(e,i,l[i])),o.geoObjects&&typeof o.geoObjects.remove=="function"?o.geoObjects.remove(e):o.remove&&typeof o.remove=="function"&&o.remove(e),v(n))}}var Pe=h(y(f(N,!0,["ObjectManager"])));class C extends u.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const{name:e,ymaps:t,dangerZone:n}=this.props,o=C.mountObject(n&&typeof n.modifyConstructor=="function"?n.modifyConstructor(t[e]):t[e],this.props);this.instance=o,this.setState({instance:o})}componentDidUpdate(e){this.instance!==null&&C.updateObject(this.instance,e,this.props)}componentWillUnmount(){C.unmountObject(this.instance,this.props)}render(){return null}static mountObject(e,t){const{instanceRef:n,parent:o,_events:l}=m(t),i=new e(c(t,"geometry"),c(t,"properties"),c(t,"options"));if(Object.keys(l).forEach(p=>x(i,p,l[p])),o&&o.geoObjects&&typeof o.geoObjects.add=="function")o.geoObjects.add(i);else{if(!o||!o.add||typeof o.add!="function")throw new Error(`No parent found to mount ${t.name}`);o.add(i)}return v(null,n,i),i}static updateObject(e,t,n){const{_events:o,instanceRef:l}=m(n),{_events:i,instanceRef:p}=m(t);if(b(n,"geometry")){const a=c(t,"geometry",{}),r=c(n,"geometry",{});Array.isArray(r)&&r!==a?Array.isArray(r[0])&&typeof r[1]=="number"?(e.geometry.setCoordinates(r[0]),e.geometry.setRadius(r[1])):e.geometry.setCoordinates(r):typeof r=="object"&&(r.coordinates!==a.coordinates&&e.geometry.setCoordinates(r.coordinates),r.radius!==a.radius&&e.geometry.setRadius(r.radius))}if(b(n,"properties")){const a=c(t,"properties"),r=c(n,"properties");a!==r&&e.properties.set(r)}if(b(n,"options")){const a=c(t,"options"),r=c(n,"options");a!==r&&e.options.set(r)}D(e,i,o),v(p,l,e)}static unmountObject(e,t){const{instanceRef:n,parent:o,_events:l}=m(t);e!==null&&(Object.keys(l).forEach(i=>M(e,i,l[i])),o.geoObjects&&typeof o.geoObjects.remove=="function"?o.geoObjects.remove(e):o.remove&&typeof o.remove=="function"&&o.remove(e),v(n))}}const ue={modifyConstructor(s){function e(t,n,o){s.call(this,{geometry:t,properties:n},o)}return e.prototype=s.prototype,e}};var xe=h(y(f(s=>u.createElement(C,d({},s,{name:"GeoObject",dangerZone:ue})),!0,["GeoObject"]))),Me=h(y(f(s=>u.createElement(C,d({},s,{name:"Circle"})),!0,["Circle"]))),ke=h(y(f(s=>u.createElement(C,d({},s,{name:"Placemark"})),!0,["Placemark"]))),Te=h(y(f(s=>u.createElement(C,d({},s,{name:"Polygon"})),!0,["Polygon"]))),Se=h(y(f(s=>u.createElement(C,d({},s,{name:"Polyline"})),!0,["Polyline"]))),De=h(y(f(s=>u.createElement(C,d({},s,{name:"Rectangle"})),!0,["Rectangle"])));export{de as Button,Me as Circle,_e as Clusterer,fe as FullscreenControl,xe as GeoObject,he as GeolocationControl,ye as ListBox,be as ListBoxItem,ie as Map,Pe as ObjectManager,le as Panorama,ke as Placemark,Te as Polygon,Se as Polyline,De as Rectangle,ve as RouteButton,je as RouteEditor,Oe as RoutePanel,ge as RulerControl,Ee as SearchControl,Ce as TrafficControl,Re as TypeSelector,me as YMaps,we as ZoomControl,oe as useYMaps,f as withYMaps};
//# sourceMappingURL=react-yandex-maps.esm-B_1H9IoL.js.map
